#include <QTRSensors.h>

QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

// Constantes PID
float Kp = 0.1;
float Ki = 0.039;
float Kd = 1.3;  
int P, I, D;
int lastError = 0;

// Controle de funcionamento
boolean onoff = false;

// Velocidade máxima e base dos motores
const uint8_t maxspeeda = 255;
const uint8_t maxspeedb = 255;
const uint8_t basespeeda = 255;
const uint8_t basespeedb = 255;

// Pinos do driver TB6612FNG
#define AIN1  6
#define AIN2  5
#define PWMA  3   // PWM motor A

#define BIN1  10
#define BIN2  9
#define PWMB  11  // PWM motor B

#define STBY  8   // Standby

// Botões
#define buttoncalibrate 12
#define buttonstart  2

// Pino IR dos leds
#define IRled 4

boolean line = true; // pista preta = 1, pista branca = 0

void setup() {
  Serial.begin(9600);

  // Configuração dos sensores QTR
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){A0, A1, A2, A3, A4, A5, A6, A7}, SensorCount);
  qtr.setEmitterPin(IRled); 

  // Configuração dos pinos dos motores
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);

  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMB, OUTPUT);

  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH); // habilita o driver

  delay(500);
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(buttonstart, INPUT_PULLUP);
  pinMode(buttoncalibrate, INPUT_PULLUP);

  boolean Ok = false;
  while (!Ok) {
    if (!digitalRead(buttoncalibrate)) {
      calibration();
      Ok = true;
    }
  }

  forward_brake(0, 0);
}

void calibration() {
  digitalWrite(LED_BUILTIN, HIGH);
  for (uint16_t i = 0; i < 200; i++) {
    qtr.calibrate();
  }
  digitalWrite(LED_BUILTIN, LOW);
}

void loop() {
  static unsigned long timeMilles;

  if (!digitalRead(buttonstart)) {
    delay(200);
    while (!digitalRead(buttonstart));
    onoff = !onoff;
    if (onoff) {
      delay(1000);
      timeMilles = millis();
    }
    else delay(50);
  }

  if (onoff) {
    PID_control();
    if ((millis() - timeMilles) >= 315000) {
      forward_brake(0, 0);
      digitalWrite(LED_BUILTIN, HIGH);
      while (1);
    }
  }
  else forward_brake(0, 0);
}

// Controle do Motor A
void setMotorA(int speed) {
  if (speed > 0) {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    analogWrite(PWMA, speed);
  } else if (speed < 0) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    analogWrite(PWMA, -speed);
  } else {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
    analogWrite(PWMA, 0);
  }
}

// Controle do Motor B
void setMotorB(int speed) {
  if (speed > 0) {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
    analogWrite(PWMB, speed);
  } else if (speed < 0) {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
    analogWrite(PWMB, -speed);
  } else {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
    analogWrite(PWMB, 0);
  }
}

void forward_brake(int posa, int posb) {
  setMotorA(posa);
  setMotorB(posb);
}

void PID_control() {
  uint16_t position;
  !line ? position = qtr.readLineBlack(sensorValues) : position = qtr.readLineWhite(sensorValues);

  int error = 3500 - position;

  // PID
  P = error;
  I = I + error;
  if (I > 1000) I = 1000;
  if (I < -1000) I = -1000;
  D = error - lastError;
  lastError = error;

  int motorspeed = P * Kp + I * Ki + D * Kd;

  // Ajuste das velocidades
  int motorspeeda = basespeeda + motorspeed;
  int motorspeedb = basespeedb - motorspeed;

  if (motorspeeda > maxspeeda) motorspeeda = maxspeeda;
  if (motorspeedb > maxspeedb) motorspeedb = maxspeedb;

  forward_brake(motorspeeda, motorspeedb);
}
